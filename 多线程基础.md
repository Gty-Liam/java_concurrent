[TOC]
## 概念

### 线程的定义
进程内的多条执行路径

### 线程安全的定义
当多个线程访问某个方法时，不管你通过怎样的调用方式、或者说这些线程如何交替地执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类是线程安全的。

### 线程的生命周期
一个线程从实例化完成，到这个线程被销毁，中间的过程。

### 线程的状态：
**新生态 New**：

一个线程被实例化，但是还没有开始执行任何操作

**就绪态 Ready**：

线程已被开启，开始争抢CPU时间片

**运行态 Run**：

线程争抢到了CPU时间片，开始执行逻辑

**阻塞态 Interrupt**：

线程在运行过程中，因为某些操作/指令，放弃了已经争抢到的CPU时间片，并且不再争抢，此时线程处于挂起(暂停)状态。

**死亡态 Dead**：

一个线程**需要**被销毁 (因为这是一个状态)。

![image](https://note.youdao.com/yws/res/23944/2E1653BBB7B34A1E9291534D10B94CDC)

## 线程基础操作
### 线程的开辟方法

1.  
    需要调用`start()`方法,使线程启动
    
    `start()`方法会开启一个新的线程,来执行`run()`中的逻辑如果直接调用`run()`方法,则线程mt不会进入就绪态。
        
    换句话说，直接执行`run()`相当于执行普通的函数，依旧是单线程，是串行执行。

2. 
    继承Thread类可读性强，但是Java中只能是单继承，如果继承了Thread就不能继承别的类的

    ==实现Runable接口的方法更推荐==，内部实现可读性低，==推荐外部实现==


> java

```java
public class ThreadCreate {
    public static void main(String[] args) {
        // 自定义类
        MyThread thread1 = new MyThread();

        // 实现Runable接口1
        Runnable r1 = new Runnable() {
            @Override
            public void run() {
                String threadName = Thread.currentThread().getName();
                for(int i=0;i<3;i++){
                    System.out.println("线程" + threadName + " : " + i);
                }
                System.out.println("子线程" + threadName + "执行完毕");
            }
        };
        Thread thread2 = new Thread(r1);

        // 外部实现Runable接口2
        MyRunable r2 = new MyRunable();
        Thread thread3 = new Thread(r2);

        //start
        thread1.start();
        thread2.start();
        thread3.start();
        System.out.println("主线程执行完毕");
    }
}

class MyThread extends Thread {
    @Override
    public void run() {
        String threadName = this.currentThread().getName();
        for(int i=0; i<3 ; i++){
            System.out.println("线程" + threadName + " : " + i);
        }
        System.out.println("子线程" + threadName + "执行完毕");
    }
}

// 外部实现Runable接口
class MyRunable implements Runnable {
    public void run() {
        String threadName = Thread.currentThread().getName();
        for(int i=0;i<3;i++){
            System.out.println("线程" + threadName + " : " + i);
        }
        System.out.println("子线程" + threadName + "执行完毕");
    }
}

```

> console

```
主线程执行完毕
线程Thread-2 : 0
线程Thread-2 : 1
线程Thread-0 : 0
线程Thread-0 : 1
线程Thread-0 : 2
子线程Thread-0执行完毕
线程Thread-1 : 0
线程Thread-1 : 1
线程Thread-1 : 2
子线程Thread-1执行完毕
线程Thread-2 : 2
子线程Thread-2执行完毕
```
### 常用方法
#### 线程的命名Name
1. 直接命名 `setName()`
   ```
    //1. 直接命名
    Thread thread = new Thread();
    thread.setName("Thread 1");
    ```
2.  使用Thread构造函数
    
    `public Thread(String name)`  
    
    `public Thread(Runnable target, String name)`

    ```
    //2. 使用构造函数
    Thread thread1 = new Thread(()->{}, "Thread 1");
    Thread thread2 = new Thread("Thread 2");
    ```
3.  继承Thread
    ```
    MyThread1 myThread1 = new MyThread1("MyThread");
    
    //
    class MyThread1 extends Thread {
        public MyThread1(String name ){
            //方法1
            super(name);
            //方法2
            //this.setName(name);
        }
    }
    ```
#### 线程的休眠Sleep
`sleep()` 注意单位是ms

可以`Runnable`实现里，也可以写在`Thread`继承里

```java
class MyRunnable implements Runnable{
    @Override
    public void run() {
       for(int i=0;i<10;i++){
           System.out.println(i);
           try {
               Thread.currentThread().sleep(1000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
    }
}
```

#### 线程的优先级Priority
`setPriority()`

1.  设置线程的优先级,只是修改这个线程可以去抢到CPU时间片的**概率**
   
    并不是优先级高的线程一定能抢到CPU时间片优先级的设置,是一个整数[0,10]的整数,默认是5
2.  设置优先级必须要**放到这个线程开始执行(start)之前**
```java
    public static void main(String[] args) {
        Runnable r = () -> {
            for(int i=0;i < 50;i++)
                System.out.println(Thread.currentThread().getName());
        };
        Thread thread1 = new Thread(r, "Thread 1");
        Thread thread2 = new Thread(r, "Thread 2");
        thread2.setPriority(8);
        thread1.setPriority(2);
        thread1.start();
        thread2.start();
    }
```

#### 线程的礼让Yield
线程礼让，指的是让当前的运行状态的线程释放自己的CPU资源，由运行状态，回到就绪状态。

值得注意的是，**礼让的线程回到就绪状态后依旧会和其他线程进行cpu时间片的争抢**，所以不一定一定都是其他线程拿到下一刻的CPU时间片。


```java
    public static void main(String[] args) {
        Runnable r = () -> {
            for(int i=0;i<10;i++) {
                System.out.println(Thread.currentThread().getName() + ": " + i);
                if(i==3){
                    Thread.yield();
                }
            }
        };

        Thread thread = new Thread(r);
        Thread thread1 = new Thread(r);
        thread.start();
        thread1.start();
    }
```

#### 线程的等待Join
`public final void join()`：此方法会把**当前线程**变为wait，直到执行join操作的线程结束，如果该线程在执行中被中断，则会抛出InterruptedException。

`public final synchronized void join(long millis)`：此方法会把**当前线程**变为wait，直到执行join操作的线程结束或者在执行join后等待millis的时间。因为线程调度依赖于操作系统的实现，因为这并不能保证当前线程一定会在millis时间变为RUnnable。

`public final synchroinzed void join(long millis, int nanos)`：此方法会把**当前线程**变为wait，直到执行join操作的线程结束或者在join后等待millis+nanos的时间。

下面的示例程序展示了Thread join方法的用法。在这段程序要保证 **当前线程**  -> main线程是最后一个完成的线程，同时保证第三个线程(third thread)在第一个线程(first thread)结束后才开始执行。
```java
public class ThreadJoinExample {

    public static void main(String[] args) {
        Thread t1 = new Thread(new MyRunnable(), "t1");
        Thread t2 = new Thread(new MyRunnable(), "t2");
        Thread t3 = new Thread(new MyRunnable(), "t3");

        t1.start();

        //start second thread after waiting for 2 seconds or if it's dead
        try {
            t1.join(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        t2.start();

        //start third thread only when first thread is dead
        try {
            t1.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        t3.start();

        //let all threads finish execution before finishing main thread
        try {
            t1.join();
            t2.join();
            t3.join();
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        System.out.println("All threads are dead, exiting main thread");
    }
}
```
## 线程同步
多线程对共享资源读写的时候才需要线程同步
### 线程同步的方法
#### synchronized

- `synchronized()` 所持有的是变量所指向在**堆内存**中的对象 
- 静态方法中`synchronized()`里不能写`this`
- `synchronized`是可以重入锁。
    - 在同一个线程里面，一个synchronized(a)方法中可以再次调用另一同样也是需要a这把锁的synchronized(a)方法
    - 子类的`synchronized`方法里面可以再调用父类的`synchronized`方法，都是去持有`this`
- 在出现异常的时候，synchronized持有的锁是会被释放的。 因此，需要注意的是，当一个线程正在处理一个共享资源的时候，处理的中途出现异常，此时的数据是异常数据，而锁已经被释放，其他线程会拿到锁进入函数执行。这很危险。
- 建议synchronized("xx")不要锁某一个字符串常量。不然引用别人的库，可能会撞上同一个字符串变量，而导致"莫名其妙"的死锁
---

**同步代码段**


将需要同步的代码写在`synchronized`下

```java
/**卖票场景**/
public static void main(String[] args) {
    Runnable sell = () -> {
        while(ticketNum > 0){
            synchronized(SynchronizedDemo.class){
                if(ticketNum <= 0){ //防止出现负票
                    break;
                }
                System.out.println("seller " + Thread.currentThread().getName() + " sells a ticket, there are " + --ticketNum + " tickets left." );
            }
        }
    };

    Thread t1  = new Thread(sell, "A");
    Thread t2  = new Thread(sell, "B");
    Thread t3  = new Thread(sell, "C");
    Thread t4  = new Thread(sell, "D");

    t1.start();
    t2.start();
    t3.start();
    t4.start();
}
```

**同步方法**

将需要同步的代码单独拿出来封装成一个函数

静态代码：同步锁就是类锁，`当前类.class`  
动态代码：同步锁时 `this`

```
public static void sellTickets() {
    synchronized(SynchronizedDemo.class){//这个地方不能用this, 静态方法没有this
        if(ticketNum > 0){
            System.out.println("seller " + Thread.currentThread().getName() + " sells a ticket, there are " + --ticketNum + " tickets left." );
        }
    }
}
```
上述代码等价于↓
```
public synchronized static void sellTickets() {
    if(ticketNum > 0){
        System.out.println("seller " + Thread.currentThread().getName() + " sells a ticket, there are " + --ticketNum + " tickets left." );
    }
}
```

#### ReentrantLock
使用`lock()`、`unlock()`，对其内的代码进行上锁

比synchronized更灵活，效率相近。

```
    ReentrantLock reentrantLock = new ReentrantLock();
    Runnable sell = () -> {
        while(ticketNum > 0){
            reentrantLock.lock();
            if(ticketNum > 0)
                System.out.println("seller " + Thread.currentThread().getName() + " sells a ticket, there are " + --ticketNum + " tickets left." );
            reentrantLock.unlock();
        }
    };
```

**尝试获取锁 trylock(), tryLock(long timeout, TimeUnit unit)**

- 当获取锁时，只有当该锁资源没有被其他线程持有才可以获取到，并且返回true，同时设置持有count为1；
- 当获取锁时，当前线程已持有该锁，那么锁可用时，返回true，同时设置持有count加1；
- 当获取锁时，如果其他线程持有该锁，无可用锁资源，直接返回false，这时候线程不用阻塞等待，可以先去做其他事情；
- 即使该锁是公平锁fairLock，使用tryLock()的方式获取锁也会是非公平的方式，只要获取锁时该锁可用那么就会直接获取并返回true。这种直接插入的特性在一些特定场景是很有用的。但是如果就是想使用公平的方式的话，可以试一试tryLock(0, TimeUnit.SECONDS)，几乎跟公平锁没区别，只是会监测中断事件。

```
ReentrantLock lock = new ReentrantLock();
public void m1(){
    try {
        lock.lock();
        System.out.println(Thread.currentThread().getName() + "  is sleeping.");
        Thread.currentThread().sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }finally {
        lock.unlock();
    }
}

/**
 * 立刻尝试获得锁，如果得到返回true；反之返回false；
 */
public void m2(){
    boolean isLock = lock.tryLock();
    if (isLock) {
        System.out.println(Thread.currentThread().getName() + " - 得到鎖 - " + isLock);
        lock.unlock();
    }
    else System.out.println(Thread.currentThread().getName() + " - 未得到锁 - " + isLock);
}

/**
 * 在一段时间内，持续尝试获得锁，如果得到返回true；反之返回false；
 */
public void m3(){
    boolean isLock = false;
    try {
        isLock = lock.tryLock(4, TimeUnit.SECONDS);  //在4秒内持续尝试获得锁
        if (isLock) {
            System.out.println(Thread.currentThread().getName() + " - 得到鎖 - " + isLock);
        } else System.out.println(Thread.currentThread().getName() + " - 未得到锁 - " + isLock);
    } catch (Exception e){
        e.printStackTrace();
    } finally {
        if(isLock) {
            System.out.println(Thread.currentThread().getName() + " 释放锁");
            lock.unlock();
        } else {
            System.out.println(Thread.currentThread().getName() + " 未得到所，不释放锁");
        }
    }
}
```

**可被中断 lockInterruptibly()**

与`lock()`相比，`lockInterruptibly`不同的地方在于，该线程在等待过程中，允许被中断事件打断，若被打断立刻停止，返回。被打断的时候会抛出异常`InterruptedException`


```
public class ReentrantLock03 {
    ReentrantLock lock = new ReentrantLock();
    public void m1(){
        try {
            lock.lock();
            System.out.println(Thread.currentThread().getName() + "  is sleeping.");
            Thread.currentThread().sleep(5000);
            System.out.println(Thread.currentThread().getName() + "  is over");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    public void m2(){
        try {
            lock.lockInterruptibly();
            System.out.println(Thread.currentThread().getName() + " - 得到鎖");
            lock.unlock();
        } catch (InterruptedException e) {
            System.out.println(Thread.currentThread().getName() + " 已经被打断");
        }
    }


    public static void main(String[] args) throws InterruptedException {
        ReentrantLock03 lock03 = new ReentrantLock03();

        Thread thread = new Thread(lock03::m1);
        Thread thread1 = new Thread(lock03::m2);

        thread.start();
        thread1.start();

        TimeUnit.SECONDS.sleep(2);
        thread1.interrupt(); // 如果不是lockInterruptibly锁，该语句无效，但不会报错
        System.out.println("thread1 is interrupted.");
    }
}
```
console↓，没有打印
```
Thread-1 - 得到鎖
Thread-0  is sleeping.
thread1 is interrupted.
Thread-0  is over
```

**公平锁**

`new ReentrantLock(true);` 

- 公平锁中, 线程严格按照先进先出(FIFO)的顺序, 获取锁资源，但效率会变低。
- 非公平锁中, 拥有锁的线程在释放锁资源的时候, 当前尝试获取锁资源的线程可以和等待队列中的第一个线程一起等概率竞争锁资源。

#### Condition
创建Condition对象： Condition condition = lock.newCondition();

`await()`：造成当前线程在接到信号或被中断之前一直处于等待状态。

`await(long time, TimeUnit unit)` ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。

`signal()`：唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。

`signal()All`：唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的。
```java
    private Integer MAX_SIZE = 10;
    private List container = new ArrayList();
    ReentrantLock lock = new ReentrantLock();
    Condition product = lock.newCondition();
    Condition consume = lock.newCondition();
     
    //... ...
    
    public void product() {
        try {
            while (true) {
                lock.lock();
                if (getSize() == MAX_SIZE) {
                    product.await();
                } else {
                    put();
                    System.out.println(Thread.currentThread().getName() + " 生产了一个对象， 剩余" + getSize());
                    consume.signalAll();
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void consume() {
        try {
            while (true) {
                lock.lock();
                if (getSize() == 0) {
                    consume.await();
                } else {
                    pop();
                    System.out.println(Thread.currentThread().getName() + " 消费了一个对象， 剩余" + getSize());
                    product.signalAll();
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

```

#### CountDownLatch
可以用来代替`wait` 和 `notify`，`CountDownLatch`不涉及锁定，当count的值为零的时候当前线程继续运行

**主要方法**

`public CountDownLatch(int count);` 构造方法参数指定了计数的次数

`public void countDown();` 当前线程调用此方法，则计数减一

`public void await();` 调用此方法会一直阻塞当前线程，直到计时器的值为0

**例子**
```java
/* mashibing.c_019.MyContainer4.java */
/*线程adding添加五个对象到list中的时候，线程listening需要输出stop*/
public static void main(String[] args) {
    CountDownLatch listeningLatch = new CountDownLatch(1);
    CountDownLatch addingLatch = new CountDownLatch(1);
    MyContainer4 container = new MyContainer4();
    Thread listening = new Thread(() -> {
        try {
            listeningLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("stop  "  + container.size());
        addingLatch.countDown();
    });

    Thread adding = new Thread(()->{
        for(int i=0;i<10;i++){
            container.add();
            System.out.println("add one Integer.");
            if(container.size() == 5){
                listeningLatch.countDown();
                try {
                    addingLatch.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    });
    listening.start();
    adding.start();
}
```

### 死锁问题

**死锁:** 多个线程彼此持有对方所需要的锁对象,而不释放自己的锁。

`wait`: 等待,是Object类中的一个方法,当前的线程释放自己的锁标记,并且让出CPU资源。使得当前的线程进入等待队列中。
> `wait` 只能释放这个线程当前所持有的锁


`notify`: 通知,是Object类中的一个方法,唤醒**该锁的**等待队列中的一个线程,使这个线程进入锁池。

`notifyAll`: 通知,是Object类中的一个方法,唤醒**该锁的**等待队列中所有的线程,并使这些线程进入锁池。


```
public static void main(String[] args) {
    Runnable r1 = ()->{
        synchronized ("A"){
            System.out.println("A线程持有了A锁，在等待B锁");
            try {
                "A".wait();  //只能释放这个线程当前所持有的锁
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized("B") {
                System.out.println("A线程持有了A、B锁");
            }
        }
    };

    Runnable r2 = ()->{
        synchronized ("B"){
            System.out.println("B线程持有了B锁，在等待A锁");
            synchronized ("A"){
                System.out.println("B线程持有了A、B锁");
                "A".notifyAll(); // A线程执行wait之后，进入的是A锁的等待队列
            }
        }
    };

    Thread t1 = new Thread(r1);
    Thread t2 = new Thread(r2);

    t1.start();
    t2.start();
}
```

### 设计模式中的同步问题
#### 单例模式（懒汉式）
等到有需要的时候才实例化对象

懒汉模式的设计要点：
1. private 构造函数
2. private 对象
2. 提供一个get接口，里面用if判断是否已经存在实例化对象，若不存在则进行实例化


在`public static Singleton getSingleton()` 中加上`synchronized`，以保证不会出现多实例化。
```java
public class SingletonTest {
    public static void main(String[] args) {
        Runnable runnable = ()->{
            Singleton.getSingleton();
        };

        for(int i=0;i<100;i++){
            new Thread(runnable).start();
        }
    }
}

class Singleton{
    private static Singleton instance = null;

    private Singleton(){
        System.out.println("实例化一个Singleton对象");
    }

    public static synchronized Singleton getSingleton(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```

**一个小优化**

减小synchronized加锁代码的粒度

```java
//qianfeng.designpattern.SingletonTest2
public static Singleton getInstance(){
    if(instance == null){
        synchronized (Singleton.class){
            if(instance == null){
                instance = new Singleton();
            }
        }
    }
    return instance;
}
```

**一个新思路，无需加锁**
```java
//qianfeng/designpattern/SingletonTest3.java
class Singleton3 {
    Singleton3(){
        System.out.println("实例化一个Singleton对象");
    }
    static class Inner {
        static private Singleton3 instance = new Singleton3();
    }
    static Singleton3 getInstance(){
        return Inner.instance;
    }
}
```

#### 生产者与消费者
```
    public synchronized void push() {
        if(productList.size() == maxSize){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        Product product = new Product("No. " + new Random().nextInt(80));
        productList.add(product);
        System.out.println("push √√ <" + product.getName() + "> into pool, there are(is) " + productList.size() + " product(s) left.");
        this.notifyAll();
    }

    public synchronized void pop() {
        if(productList.size() == 0){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        Product product = productList.remove(0);
        System.out.println("pop ×× <" + product.getName() + "> into pool, there are(is) " + productList.size() + " product(s) left.");
        this.notifyAll();
    }
```

[马士兵多线程补充]()

### volatile
`volatile` 保证两个相乘之间的变量可见性  
`synchronized` 既保证了可见性，又保证了原子性

因此， `volatile`的效率比`synchronized`高得多

```java
static Boolean run = true;

public void running(){
    System.out.println("running...");
    while(run){
    }
    System.out.println("stop...");
}

public static void main(String[] args) {
    Thread thread = new Thread(()->new VolatileDemo().running());
    thread.start();
    try {
        Thread.currentThread().sleep(10); //4ms还是会写回内存的，5ms就不会了，应该跟电脑性能也有关系
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("wake");
    run = false;
}
```
上面这个程序，直观来讲，本该顺利结束，得到以下输出
```txt
running...
wake
stop...
```
但实则始终不会输出‘stop...’



原因是因为cpu，会从内存中取值出来，读进自己的寄存器然后计算。一般来讲cpu完成计算完成后，会把值重新写回内存，之后有需要会再从内存中读取。  
但是子线程一直在忙碌，cpu没有空闲把值放回内存或从内存里重新读run，所以`run = false`虽然写回内存，但是子线程cpu没有去读，就始终在循环。

`volatile`的含义是，当被`volatile`修饰的变量(`run`)被修改的时候，会通知其他线程的缓冲区去更新主内存中该变量的值，即**缓存过期通知**，或者是说实现了**线程之间的可见性**。

线程之间的不可见，其实是看运气的，看cpu到底重不重读内存。

**发现在`while(true){}`中，while里面空循环不写任何东西，包括`syso`，就容易出现不可见性问题**

![image](https://note.youdao.com/yws/res/24500/96B7C49F256A4C23947E263B80CD9270)

### AtomXXX类
10个线程，对共享Int变量累加，除了使用下述的synchronized同步方法进行累加以外，还可以使用AtomXXX类。

 AtomXXX类本身方法都是原子性的,当然多个原子性方法之间依旧是不具备原子性的。
 
synchronized的实现方法↓
```java
    volatile Integer count = 0;
    public synchronized void increase(){
        for(int i=0;i<5000;i++) count++;
    }
```

```
    for(int i=0;i<10;i++){
        threadList.add(new Thread(demo::increase));
    }
    threadList.forEach(Thread::start);
```

AtomXXX类的实现方法
```java
    AtomicInteger count = new AtomicInteger(0);
    public void increase(){
        for(int i=0;i<5000;i++) count.incrementAndGet();
    }
```

### 线程局部变量 ThreadLocal

在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。

```java
public class ThreadLocalDemo {
    private static String personName = "lisi";
    private static ThreadLocal<Integer> age = new ThreadLocal<>();

    public static void main(String[] args) {
        age.set(30);  // 对主线程的局部变量进行设置
        Thread t1 = new Thread(()->{
            try{
                Thread.sleep(300);
                System.out.println("t1 personName :" + personName);
                System.out.println("t1 age :" + age.get());
            } catch (InterruptedException e){
                e.printStackTrace();
            }
        });
        Thread t2 = new Thread(()->{
            System.out.println("t2 set personName = Zhangsan and age = 40");
            personName = "Zhangsan";
            age.set(40);
            System.out.println("t2 personName ：" + personName);
            System.out.println("t2 age：" + age.get());
        });

        t2.start();
        t1.start();
        try {
            Thread.sleep(400);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("main Thread age : " + age.get());
    }
}
```
console↓，注意是三个age的值，各自独立
```txt
t2 set personName = Zhangsan and age = 40
t2 personName ：Zhangsan
t2 age：40
t1 personName :Zhangsan
t1 age :null
main Thread age : 30
```

### 同步容器
#### ConcurrentMap
- **HashMap:** 使用hash实现map。
- **TreeMap:** 使用tree实现map。相比hashMap，它是有序的。适用于单线程，不带锁。

↓　↓　↓　==需要并发==

- **HashTable:** 函数默认都是带锁的，但效率比较低。
- **Collections.synchronizedXXX:** 给Map,List等上锁。 e.g. `Map hashMap = Collections.synchronizedMap(new HashMap());` -> 约等于 HashTable

↓　↓　↓　==并发量高==

- **ConcurrentHashMap:** 线程安全，分段锁，把内部存储分为**16段**，读写数据时只锁定当前段，所以效率比较高。

↓　↓　↓　==并发量高，且需要排序==

- **ConcurrentSkipListMap:** 适用于高并发，且有序。因为插入时排序，所以插入操作的效率不高。

#### CopyOnWriteList
- **CopyOnWriteList**:  在对数据进行修改的时候，会对原数据先进行复制，然后在副本上进行修改，在修改完成后，将对象的引用指向修改完后的副本。  因此不需要对数据进行加锁，**读的效率很高，写的效率极其的极其的低。**
- **Vector**: 线程安全。
- **ArrayList**:  线程不安全。
- 
**小插曲**

在使用ArrayList进行效率对比的时候，经常会出现越界报错。

猜想是因为ArrayList是用Array来实现的，插入元素时，若此时数组已满，则会扩容至原来的1.5倍。但是在多线程的情况下，判断是或扩容的语句和扩容语句之间没有上锁，所以在临界扩容的时候，容易数据越界。
```java
Exception in thread "Thread-58" Exception in thread "Thread-56" java.lang.ArrayIndexOutOfBoundsException: 826417
	at java.util.ArrayList.add(ArrayList.java:459)
	at mashibing.c_025.T2_CopyOnWriteList.lambda$main$0(T2_CopyOnWriteList.java:21)
	at java.lang.Thread.run(Thread.java:748)
```
java.util.ArrayList.add(ArrayList.java:459)  ↓ 
```java
/**
 * Appends the specified element to the end of this list.
 *
 * @param e element to be appended to this list
 * @return <tt>true</tt> (as specified by {@link Collection#add})
 */
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // 判断当前size+1之后是否需要扩容。
    //只剩一个空位的时候，多个线程都到了这里...那么先后执行下面这句话 
    elementData[size++] = e;  // size++也不是原子的，所以很容易报错。
    return true;
}
```


#### ConcurrentQueue
并发加锁的

ConcurrentLinkedQueue： 单向链表实现的队列  
无界队列

- `offer` ： 添加一个元素到队列的尾部
- `add` : 与`offer`完全相同
- `poll` ： 移除并返回第一个元素
- `peek` ： 返回第一个元素, 但不移除
- `remove(Object o)`: 移除指定元素o

ConcurrentLinkedDeque： 双向链表实现的队列

#### BlockingQueue
阻塞式队列

实现的同步容器：

- LinkedBlockingQueue：感觉不是很好用, 自己没有办法控制那个锁，很不方便。
    - `put()` : 如果满了就会自动等待
    - `take()` : 如果空了就会自动等待

- ArrayBlockingQueue：
    - `add(E e)` : 往队列中添加元素，若已满则会报错
    - `offer(E e)` ： 往队列中添加元素，若已满则会返回false
    - `offer(E e, long timeout, TimeUnit unit)`：在一定时间段内，尝试往里加
    - `put`: 添加元素，满时会自动阻塞

- TransferQueue：
    - `transfer(E e)`: 直接将元素交付给消费者，而不是放在队列当中。当没有消费者的时候，该函数会阻塞。 

- SynchronousQueue:  与TransfrtQueue很像。其队列容量可看做为0.

    添加元素用`put`,`put`会等待消费者，将元素直接交付给消费者。若调用`add`则会报错。
    
    `put`的逻辑就是直接调用`transfer`
    ```java
    /**
     * Adds the specified element to this queue, waiting if necessary for
     * another thread to receive it.
     *
     * @throws InterruptedException {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     */
    public void put(E e) throws InterruptedException {
        if (e == null) throw new NullPointerException();
        if (transferer.transfer(e, false, 0) == null) {
            Thread.interrupted();
            throw new InterruptedException();
        }
    }
    ```
    
    #### DelayQueue
    放入的元素必须等到一段时间之后才能被取出，常用于执行定时任务。传入的元素对象的类必须继承了Delayed。
    
## 线程池
### 常见类&接口
#### Executor
顶层接口，没有父类接口，里面只有一个函数`execute`

```txt
void execute(Runnable command)

Executes the given command at some time in the future. The command may execute in a new thread, in a pooled thread, or in the calling thread, at the discretion of the Executor implementation.
```

#### Callable
与`Runnable`很像，但是`Callable`可以自定义返回值和异常。
> The Callable interface is similar to Runnable, in that both are designed for classes whose instances are potentially executed by another thread. A Runnable, however, does not return a result and cannot throw a checked exception.

#### ExecutorService
继承于`Execute`，可以理解为在后台的服务，始终等待执行任务。
- execute：执行Runnable任务
- submit：可以执行Runnable 和 Callable 任务

#### Future
> 个人理解：获取提交给线程的任务的运行状态以及结果。

Future<V>接口是用**来获取异步计算结果**的，说白了就是对具体的Runnable或者Callable对象任务执行的++结果进行获取++，判断任务状态++是否取消++，++是否完成++等操作。

- `V get()` ：获取异步执行的结果，如果没有结果可用，**此方法会阻塞直到异步计算完成。**
- `V get(Long timeout , TimeUnit unit)` ：获取异步执行结果，如果没有结果可用，此方法会阻塞，但是会有时间限制，如果阻塞时间超过设定的timeout时间，该方法将抛出异常。
- `boolean isDone()` ：如果任务执行结束，无论是正常结束或是中途取消还是发生异常，都返回true。
- `boolean isCanceller() `：如果任务完成前被取消，则返回true。
- `boolean cancel(boolean mayInterruptRunning)` ：只有当任务已经开始，且调用此方法成功使任务终止的情况下，才会返回True

```java
ExecutorService executorService = Executors.newFixedThreadPool(5);
    Future<Integer> future = executorService.submit(()->{
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            return 10086;
        }
    });
    System.out.println(future.isDone());
    System.out.println(future.isCancelled());
    System.out.println(future.get());  //会阻塞2s，直等到futureTask任务执行完return结果才往下执行
    System.out.println(future.isDone());
}
```
console ↓
```
false
false
10086
true
```

#### FutureTask
```
graph LR
FutureTask--implements-->RunnableFuture
RunnableFuture--extends-->Runnable
RunnableFuture--extends-->Future
```

```java
public class FutureTask<V> implements RunnableFuture<V> {  
```
```java
public interface RunnableFuture<V> extends Runnable, Future<V> {  
    void run();  
}  
```
FutureTask除了实现了Future接口外还实现了Runnable接口，**即可以通过Runnable接口实现线程，也可以通过Future取得线程执行完后的结果**，因此FutureTask也可以直接提交给Executor执行。

FutureTask比Runnable多了返回值，比Callable多了`get`阻塞等待结果

仔细看看下面的示例代码
```java
FutureTask futureTask = new FutureTask(()->{
    System.out.println("execute future task.");
    Thread.sleep(2000);
    return 1000;
});

new Thread(futureTask).start();
System.out.println(futureTask.get());  //主线程会阻塞2s, 等到futureTask任务执行完return结果位置
```
#### ForkJoinTask
**RecursiveAction**

没有返回值

**RecursiveTask**



### 线程池
#### newFixedThreadPool
`Executors.newFixedThreadPool()`
```
Runnable r = ()->{
    System.out.println(Thread.currentThread().getName());
};

ExecutorService executorService = Executors.newFixedThreadPool(5);

for(int i=0;i<7;i++){
    executorService.execute(r);
}
System.out.println("executorService : " + executorService);
executorService.shutdown();
System.out.println("is shut down? : " + executorService.isShutdown());
System.out.println("is terminated? : " + executorService.isTerminated());
System.out.println("executorService : " + executorService);

try {
    TimeUnit.SECONDS.sleep(2);
    System.out.println("sleep 2s");
} catch (InterruptedException e) {
    e.printStackTrace();
}

System.out.println("executorService : " + executorService);
System.out.println("is shut down? : " + executorService.isShutdown());
System.out.println("is terminated? : " + executorService.isTerminated());
```
![](https://note.youdao.com/yws/public/resource/61c028b69d8f3ba47872d096f0ae51f8/xmlnote/6D5B5FA1A6174936A50A2E9B1444610A/25467)

#### 多线程并行计算示例 - 寻找质数
**单线程** 

```
Long start = System.currentTimeMillis();
List<Integer> primes = getPrimeList(1, 50000000);
Long end = System.currentTimeMillis();
System.out.println("耗时： " + (end - start));
```
`耗时： 54216`

**四线程 - 并行计算**
```
ExecutorService es = Executors.newFixedThreadPool(4);
MyCallable task1 = new MyCallable(1, 20000000);
MyCallable task2 = new MyCallable(20000000, 36000000);
MyCallable task3 = new MyCallable(36000000, 44000000);
MyCallable task4 = new MyCallable(44000000, 50000000);
Long start1 = System.currentTimeMillis();
Future f1 = es.submit(task1);
Future f2 = es.submit(task2);
Future f3 = es.submit(task3);
Future f4 = es.submit(task1);
f1.get();f2.get();f3.get();f4.get();

//下面的写法会一级级阻塞
Long end1 = System.currentTimeMillis();
System.out.println("耗时： " + (end1 - start1));
```
`耗时： 30606`

![](https://note.youdao.com/yws/public/resource/61c028b69d8f3ba47872d096f0ae51f8/xmlnote/C752386F11CE43DBA66F963709E4BFC2/25566)

#### newFixedThreadPool
- 自动创建线程，当任务来时，如果池中没有空闲线程，就会自动创建线程。

- 在线程空闲60s之后，就会自动销毁线程

从构造函数中可以看出:

`newFixedThreadPool`就是把最大线程和最小线程都限制为固定值`nThreads`，而线程的最大闲置时间`keepAliveTime` 为0.  
`newCachedThreadPool`最小线程数为0，最大线程数为最大值，线程闲置时间为60s

```java
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>(),
                                  threadFactory);
}
                                      
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}                                      
```

当池中有闲置线程的时候，新来的任务不会创建新的线程，而是去使用闲置的线程，以下是一个示例。
```java
ExecutorService es = Executors.newCachedThreadPool();
System.out.println(es);

for(int i=0;i<2;i++) {
    es.submit(() -> {
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
}
System.out.println(es);
System.out.println("休息1s");
Thread.sleep(1000);
System.out.println(es);
es.submit(()->{
    System.out.println("是否会使用闲置线程，还是重新开启一个新的线程");
    System.out.println(es);
});
Thread.sleep(70000);
System.out.println(es);
```
```txt
java.util.concurrent.ThreadPoolExecutor@7f31245a[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]
java.util.concurrent.ThreadPoolExecutor@7f31245a[Running, pool size = 2, active threads = 2, queued tasks = 0, completed tasks = 0]
休息1s
java.util.concurrent.ThreadPoolExecutor@7f31245a[Running, pool size = 2, active threads = 0, queued tasks = 0, completed tasks = 2]
是否会使用闲置线程，还是重新开启一个新的线程
java.util.concurrent.ThreadPoolExecutor@7f31245a[Running, pool size = 2, active threads = 1, queued tasks = 0, completed tasks = 2]
java.util.concurrent.ThreadPoolExecutor@7f31245a[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 3]
```
![](https://note.youdao.com/yws/public/resource/61c028b69d8f3ba47872d096f0ae51f8/xmlnote/F9C9DB356FE043229E2A46CDD6439930/25594)

**自定义设置超时时间的方法**

在创建线程池的时候，创建的是`ThreadPoolExecutor`，但返回的是其父类`ExecutorService`，而`ExecutorService`里没有`setKeepAliveTime()`方法，所以强制转换，然后调用`setKeepAliveTime()`。
```java
ThreadPoolExecutor es = (ThreadPoolExecutor)Executors.newCachedThreadPool();  //个人想到的修改过期时间的方法
es.setKeepAliveTime(10L, TimeUnit.SECONDS); //10s超时
```

#### SingleThreadPool
顾名思义，池中只有一个线程，这个线程池的意义就是可以保证任务的顺序执行。

#### ScheduledPool
定时(一段时间间隔)重复执行任务的线程池

注意`newScheduledThreadPool`返回类型是`ScheduledExecutorService`，而不是`ExecutorService`
```java
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
```
`scheduleAtFixedRate()`执行定时任务
```java
/**
 * @param command the task to execute, Runnable任务
 * @param initialDelay the time to delay first execution，第一次执行任务前的延时
 * @param period the period between successive executions，每次执行的时间间隔
 * @param unit the time unit of the initialDelay and period parameters，时间的单位
 */
public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit);
```
####  WorkStealingPool
每个处理器核，都有一个队列存储着需要完成的任务。对于多核的机器来说，当一个核对应的任务处理完毕后，就可以去帮助其他的核处理任务。

`WorkStealPool`，本质是一个`ForkJoinPool`，其创建的线程是daemon Thread

daemon Thread：精灵线程（守护线程），即 本身无法使虚拟主机保持活动的线程。该线程本身的活动不能阻止java进程的结束。与之相对的普通的线程称之为用户线程。当主线程以及其他普通用户线程都结束了JAVA进程才会结束。而精灵线程则无论结束与否，都不会影响JAVA进程的结束

> 但是其实我觉得还是没有什么区别呀，因为没有可看出来在在分配任务的时候，有单独的任务队列？？？

#### ForkJoinPool
本质和归并排序差不多，递归思想
```java
MyRecursiveAction myRecursiveAction = new MyRecursiveAction(0, SIZE);
new ForkJoinPool().execute(myRecursiveAction);

//....

@Override
protected void compute() {
    if(endIndex - startIndex <= MAX_NUM){
        long sum = 0;
        for(int i=startIndex;i<endIndex;i++){
            sum += num_arr[i];
        }
        lock.lock();
        total += sum;
        lock.unlock();
    } else{
        int middle = (startIndex + endIndex) / 2;
        MyRecursiveAction task1 = new MyRecursiveAction(startIndex, middle);
        MyRecursiveAction task2 = new MyRecursiveAction(middle, endIndex);
        task1.fork();
        task2.fork();
    }
}
```

### ParallelStream （可以再学习一点）
会自动使用多线程

```java
numList.forEach(num -> isPrime(num)); // 130ms

numList.parallelStream().forEach(T14_ParallelStreamAPI::isPrime); //47ms
```

---

## 源代码

[源码下载(zip)](https://note.youdao.com/yws/api/personal/file/B97969B79E904766A94D6FE92F2E53D5?method=download&shareKey=24430f7b5d99b1a91ca6de0f61a42856)

[github](https://github.com/Gty-Liam/java_concurrent)